<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>three.js + ShockWave shaderPass II</title>
    <style>
      body {
        margin: 0;
        overflow: hidden;
        background: #000;
        font-family: sans-serif;
        user-select:none;
      }
      canvas {
        display: block;
      }
      .dg.ac {
        z-index: 10;
      }
    </style>
  </head>
  <body>
    <canvas id="goo-canvas"></canvas>
    <script type="module">
      import * as THREE from 'https://cdn.skypack.dev/three@0.136.0/build/three.module.js';
      import { OrbitControls } from 'https://cdn.skypack.dev/three@0.136.0/examples/jsm/controls/OrbitControls.js';
      import { EffectComposer } from 'https://cdn.skypack.dev/three@0.136.0/examples/jsm/postprocessing/EffectComposer.js';
      import { RenderPass } from 'https://cdn.skypack.dev/three@0.136.0/examples/jsm/postprocessing/RenderPass.js';
      import { ShaderPass } from 'https://cdn.skypack.dev/three@0.136.0/examples/jsm/postprocessing/ShaderPass.js';
      import { UnrealBloomPass } from 'https://cdn.skypack.dev/three@0.136.0/examples/jsm/postprocessing/UnrealBloomPass.js';
      import { GUI } from 'https://cdn.skypack.dev/dat.gui@0.7.7';

      const canvas = document.querySelector('#goo-canvas');
      const renderer = new THREE.WebGLRenderer({ canvas });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(window.devicePixelRatio);

      const scene = new THREE.Scene();
      const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 100);
      camera.position.z = 5;

      const controls = new OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;

      const light = new THREE.PointLight(0xffffff, 1);
      light.position.set(5, 5, 5);
      scene.add(light);

      const rotatingGroup = new THREE.Group();
      scene.add(rotatingGroup); 

      const starGeometry = new THREE.BufferGeometry();
      const starCount = 1000;
      const starsPositions = new Float32Array(starCount * 3);
      for (let i = 0; i < starCount * 3; i++) {
        starsPositions[i] = (Math.random() - 0.5) * 200;
      }
      starGeometry.setAttribute('position', new THREE.BufferAttribute(starsPositions, 3));
      const starMaterial = new THREE.PointsMaterial({
        color: 'cyan',
        size: 0.1,
        sizeAttenuation: true
      });
      const stars = new THREE.Points(starGeometry, starMaterial);
      scene.add(stars);

      const innerGeometry = new THREE.IcosahedronGeometry(1, 3);
      const innerMaterial = new THREE.MeshStandardMaterial({
        color: 0x222222,
        roughness: 0.5,
        metalness: 1,
        flatShading: true,
        transparent: true,
        opacity: 0.7
      });
      const innerMesh = new THREE.Mesh(innerGeometry, innerMaterial);
      rotatingGroup.add(innerMesh); 
      
      const outerGeometry = new THREE.IcosahedronGeometry(1.15, 3);
      const wireframeMaterial = new THREE.MeshBasicMaterial({
        color: 0xffffff,
        wireframe: true,
        transparent: true,
        opacity: 0.1
      });
      const wireframeMesh = new THREE.Mesh(outerGeometry, wireframeMaterial);
      rotatingGroup.add(wireframeMesh); 
      
      const positions = [];
      const posAttr = outerGeometry.attributes.position;
      for (let i = 0; i < posAttr.count; i++) {
        positions.push(posAttr.getX(i), posAttr.getY(i), posAttr.getZ(i));
      }

      const particleGeometry = new THREE.BufferGeometry();
      particleGeometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
      const particleMaterial = new THREE.PointsMaterial({
        color: 'cyan',
        size: 0.025
      });
      const particles = new THREE.Points(particleGeometry, particleMaterial);
      rotatingGroup.add(particles); 
      
      const composer = new EffectComposer(renderer);
      composer.addPass(new RenderPass(scene, camera));

      const bloomPass = new UnrealBloomPass(
        new THREE.Vector2(window.innerWidth, window.innerHeight),
        1.5,
        0.4,
        0.05
      );
      composer.addPass(bloomPass);

      const maxRipples = 10;
      const RippleShader = {
        uniforms: {
          tDiffuse: { value: null },
          centers: { value: Array(maxRipples).fill().map(() => new THREE.Vector2(0.5, 0.5)) },
          times: { value: Array(maxRipples).fill(0.0) },
          rippleActive: { value: Array(maxRipples).fill(0.0) },
          maxRadius: { value: 1.0 },
          amplitude: { value: 0.03 },
          secondaryAmplitude: { value: 0.01 },
          speed: { value: 0.3 },
          frequency: { value: 10.0 },
          aspect: { value: window.innerWidth / window.innerHeight },
          smoothing: { value: 0.95 },
          sigma: { value: 0.6 },
          fadeDuration: { value: 6.0 }
        },
        vertexShader: `
          varying vec2 vUv;
          void main() {
            vUv = uv;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
          }
        `,
        fragmentShader: `
          #define PI 3.14159265359
          #define MAX_RIPPLES ${maxRipples}
          uniform sampler2D tDiffuse;
          uniform vec2 centers[MAX_RIPPLES];
          uniform float times[MAX_RIPPLES];
          uniform float rippleActive[MAX_RIPPLES];
          uniform float maxRadius;
          uniform float amplitude;
          uniform float secondaryAmplitude;
          uniform float speed;
          uniform float frequency;
          uniform float aspect;
          uniform float smoothing;
          uniform float sigma;
          uniform float fadeDuration;
          varying vec2 vUv;

          void main() {
            vec2 uv = vUv;
            vec2 totalWave = vec2(0.0);
            for (int i = 0; i < MAX_RIPPLES; i++) {
              if (rippleActive[i] > 0.0) {
                vec2 aspectUV = vec2((uv.x - centers[i].x) * aspect, uv.y - centers[i].y);
                float dist = length(aspectUV);
                float t = times[i] * speed;
                if (dist < t) {
                  float normDist = dist / maxRadius;
                  float decay = 1.0 / (1.0 + sigma * normDist * normDist);
                  float timeFade = pow(smoothstep(fadeDuration, fadeDuration - 2.0, times[i]), 2.0);
                  float smoothFactor = smoothstep(1.0 - smoothing, 1.0, normDist);
                  float primaryWave = amplitude * sin(frequency * (t - dist)) * decay * (1.0 - smoothFactor) * timeFade;
                  float secondaryWave = secondaryAmplitude * sin(0.5 * frequency * (t - dist) + PI) * decay * (1.0 - smoothFactor) * timeFade;
                  totalWave += normalize(aspectUV) * (primaryWave + secondaryWave);
                }
              }
            }
            uv += totalWave;
            gl_FragColor = texture2D(tDiffuse, clamp(uv, 0.0, 1.0));
          }
        `
      };

      const ripplePass = new ShaderPass(RippleShader);
      ripplePass.renderToScreen = true;
      composer.addPass(ripplePass);

      let ripples = [];
      const rippleDuration = 25;

      window.addEventListener('dblclick', (event) => {
        const mouseX = (event.clientX / window.innerWidth) * 2 - 1;
        const mouseY = -(event.clientY / window.innerHeight) * 2 + 1;
        const center = new THREE.Vector2((mouseX + 1) / 2, (mouseY + 1) / 2);
        const startTime = performance.now() / 1000;
        ripples.push({ center, startTime });
        if (ripples.length > maxRipples) {
          ripples.shift();
        }
        updateRippleUniforms();
      });

      function updateRippleUniforms() {
        const centers = ripplePass.uniforms.centers.value;
        const times = ripplePass.uniforms.times.value;
        const active = ripplePass.uniforms.rippleActive.value;
        for (let i = 0; i < maxRipples; i++) {
          if (i < ripples.length) {
            centers[i].copy(ripples[i].center);
            times[i] = performance.now() / 1000 - ripples[i].startTime;
            active[i] = times[i] < rippleDuration ? 1.0 : 0.0;
          } else {
            active[i] = 0.0;
          }
        }
      }

      window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
        composer.setSize(window.innerWidth, window.innerHeight);
        bloomPass.setSize(window.innerWidth, window.innerHeight);
        ripplePass.uniforms.aspect.value = window.innerWidth / window.innerHeight;
      });

      function animate() {
        requestAnimationFrame(animate);
        controls.update();

        rotatingGroup.rotation.x += 0.002;
        rotatingGroup.rotation.y += 0.003;

        if (ripples.length > 0) {
          updateRippleUniforms();
          ripples = ripples.filter(ripple => (performance.now() / 1000 - ripple.startTime) < rippleDuration);
        }

        composer.render();
      }

      animate();

      const gui = new GUI();
      gui.close();

      const rippleFolder = gui.addFolder('Ripple Shader');
      rippleFolder.add(ripplePass.uniforms.maxRadius, 'value', 0.5, 2.0).name('Max Radius');
      rippleFolder.add(ripplePass.uniforms.amplitude, 'value', 0.01, 0.1).name('Amplitude');
      rippleFolder.add(ripplePass.uniforms.secondaryAmplitude, 'value', 0.0, 0.05).name('Secondary Amplitude');
      rippleFolder.add(ripplePass.uniforms.speed, 'value', 0.1, 1.0).name('Speed');
      rippleFolder.add(ripplePass.uniforms.frequency, 'value', 5.0, 20.0).name('Frequency');
      rippleFolder.add(ripplePass.uniforms.smoothing, 'value', 0.5, 1.0).name('Smoothing');
      rippleFolder.add(ripplePass.uniforms.sigma, 'value', 0.1, 1.0).name('Sigma');
      rippleFolder.add(ripplePass.uniforms.fadeDuration, 'value', 1.0, 8.0).name('Fade Duration');
      rippleFolder.open();

      const bloomFolder = gui.addFolder('Bloom');
      bloomFolder.add(bloomPass, 'strength', 0, 3).name('Strength');
      bloomFolder.add(bloomPass, 'radius', 0, 1).name('Radius');
      bloomFolder.add(bloomPass, 'threshold', 0, 1).name('Threshold');
      bloomFolder.open();

      let title3;
      document.addEventListener('DOMContentLoaded', () => {
        const title1 = document.createElement('h3');
        title1.classList.add('title_ui', '_1');
        title1.textContent = 'three.js + ShockWave shaderPass II';

        const title2 = document.createElement('h3');
        title2.classList.add('title_ui', '_2');
        title2.textContent = 'double click';

        title3 = document.createElement('h3');
        title3.classList.add('title_ui', '_3');
        title3.textContent = 'fullscreen on';

        document.body.appendChild(title1);
        document.body.appendChild(title2);
        document.body.appendChild(title3);

        const titles = document.querySelectorAll('.title_ui');

        titles.forEach(title => {
          title.style.position = 'absolute';
          title.style.fontFamily = 'arial';
          title.style.color = '#fff';
          title.style.fontSize = '.8rem';
        });

        title1.style.top = '20px';
        title1.style.left = '30px';

        title2.style.bottom = '20px';
        title2.style.left = '30px';

        title3.style.bottom = '20px';
        title3.style.right = '30px';
        title3.style.fontSize = '.8rem';
        title3.style.cursor = 'pointer';

        title3.addEventListener('click', toggleFullscreen);

      });

      function toggleFullscreen() {
        if (!document.fullscreenElement) {
          document.documentElement.requestFullscreen();
          title3.textContent = 'fullscreen off';
        } else if (document.exitFullscreen) {
          document.exitFullscreen();
          title3.textContent = 'fullscreen on';
        }
      }
    </script>
  </body>
</html>